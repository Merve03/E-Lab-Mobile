{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n  if (typeof collection.getChildren === 'function') return collection.getChildren(node.key);\n  return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n  if (index < 0) return undefined;\n  var i = 0;\n  for (var item of iterable) {\n    if (i === index) return item;\n    i++;\n  }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n  var lastItem = undefined;\n  for (var value of iterable) lastItem = value;\n  return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n  if (a.parentKey === b.parentKey) return a.index - b.index;\n  var aAncestors = [].concat(_toConsumableArray($c5a24bc478652b5f$var$getAncestors(collection, a)), [a]);\n  var bAncestors = [].concat(_toConsumableArray($c5a24bc478652b5f$var$getAncestors(collection, b)), [b]);\n  var firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex(function (a, i) {\n    return a !== bAncestors[i];\n  });\n  if (firstNonMatchingAncestor !== -1) {\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n  if (aAncestors.findIndex(function (node) {\n    return node === b;\n  }) >= 0) return 1;else if (bAncestors.findIndex(function (node) {\n    return node === a;\n  }) >= 0) return -1;\n  return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n  var parents = [];\n  var currNode = node;\n  while ((currNode === null || currNode === void 0 ? void 0 : currNode.parentKey) != null) {\n    currNode = collection.getItem(currNode.parentKey);\n    if (currNode) parents.unshift(currNode);\n  }\n  return parents;\n}\nexport { $c5a24bc478652b5f$export$1005530eda016c13 as getChildNodes, $c5a24bc478652b5f$export$fbdeaa6a76694f71 as getFirstItem, $c5a24bc478652b5f$export$5f3398f8733f90e2 as getNthItem, $c5a24bc478652b5f$export$7475b2c64539e4cf as getLastItem, $c5a24bc478652b5f$export$8c434b3a7a4dad6 as compareNodeOrder };","map":{"version":3,"names":["$c5a24bc478652b5f$export$1005530eda016c13","node","collection","getChildren","key","childNodes","$c5a24bc478652b5f$export$fbdeaa6a76694f71","iterable","$c5a24bc478652b5f$export$5f3398f8733f90e2","index","undefined","i","item","$c5a24bc478652b5f$export$7475b2c64539e4cf","lastItem","value","$c5a24bc478652b5f$export$8c434b3a7a4dad6","a","b","parentKey","aAncestors","concat","_toConsumableArray","$c5a24bc478652b5f$var$getAncestors","bAncestors","firstNonMatchingAncestor","slice","length","findIndex","parents","currNode","getItem","unshift"],"sources":["C:\\Users\\merve\\node_modules\\@react-stately\\collections\\dist\\packages\\@react-stately\\collections\\src\\getChildNodes.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {Collection, Node} from '@react-types/shared';\n\nexport function getChildNodes<T>(node: Node<T>, collection: Collection<Node<T>>): Iterable<Node<T>> {\n  // New API: call collection.getChildren with the node key.\n  if (typeof collection.getChildren === 'function') {\n    return collection.getChildren(node.key);\n  }\n\n  // Old API: access childNodes directly.\n  return node.childNodes;\n}\n\nexport function getFirstItem<T>(iterable: Iterable<T>): T | undefined {\n  return getNthItem(iterable, 0);\n}\n\nexport function getNthItem<T>(iterable: Iterable<T>, index: number): T | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n\n  let i = 0;\n  for (let item of iterable) {\n    if (i === index) {\n      return item;\n    }\n\n    i++;\n  }\n}\n\nexport function getLastItem<T>(iterable: Iterable<T>): T | undefined {\n  let lastItem: T | undefined = undefined;\n  for (let value of iterable) {\n    lastItem = value;\n  }\n\n  return lastItem;\n}\n\nexport function compareNodeOrder<T>(collection: Collection<Node<T>>, a: Node<T>, b: Node<T>) {\n  // If the two nodes have the same parent, compare their indices.\n  if (a.parentKey === b.parentKey) {\n    return a.index - b.index;\n  }\n\n  // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n  // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n  // ancestor of the same level\n  let aAncestors = [...getAncestors(collection, a), a];\n  let bAncestors = [...getAncestors(collection, b), b];\n  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i) => a !== bAncestors[i]);\n  if (firstNonMatchingAncestor !== -1) {\n    // Compare the indices of two children within the common ancestor.\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n\n  // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n  if (aAncestors.findIndex(node => node === b) >= 0) {\n    return 1;\n  } else if (bAncestors.findIndex(node => node === a) >= 0) {\n    return -1;\n  }\n\n  // ðŸ¤·\n  return -1;\n}\n\nfunction getAncestors<T>(collection: Collection<Node<T>>, node: Node<T>): Node<T>[] {\n  let parents: Node<T>[] = [];\n\n  let currNode: Node<T> | null = node;\n  while (currNode?.parentKey != null) {\n    currNode = collection.getItem(currNode.parentKey);\n    if (currNode) {\n      parents.unshift(currNode);\n    }\n  }\n\n  return parents;\n}\n"],"mappings":";AAcO,SAASA,0CAAiBC,IAAa,EAAEC,UAA+B;EAE7E,IAAI,OAAOA,UAAA,CAAWC,WAAW,KAAK,YACpC,OAAOD,UAAA,CAAWC,WAAW,CAACF,IAAA,CAAKG,GAAG;EAIxC,OAAOH,IAAA,CAAKI,UAAU;AACxB;AAEO,SAASC,0CAAgBC,QAAqB;EACnD,OAAOC,yCAAA,CAAWD,QAAA,EAAU;AAC9B;AAEO,SAASC,0CAAcD,QAAqB,EAAEE,KAAa;EAChE,IAAIA,KAAA,GAAQ,GACV,OAAOC,SAAA;EAGT,IAAIC,CAAA,GAAI;EACR,KAAK,IAAIC,IAAA,IAAQL,QAAA,EAAU;IACzB,IAAII,CAAA,KAAMF,KAAA,EACR,OAAOG,IAAA;IAGTD,CAAA;EACF;AACF;AAEO,SAASE,0CAAeN,QAAqB;EAClD,IAAIO,QAAA,GAA0BJ,SAAA;EAC9B,KAAK,IAAIK,KAAA,IAASR,QAAA,EAChBO,QAAA,GAAWC,KAAA;EAGb,OAAOD,QAAA;AACT;AAEO,SAASE,yCAAoBd,UAA+B,EAAEe,CAAU,EAAEC,CAAU;EAEzF,IAAID,CAAA,CAAEE,SAAS,KAAKD,CAAA,CAAEC,SAAS,EAC7B,OAAOF,CAAA,CAAER,KAAK,GAAGS,CAAA,CAAET,KAAK;EAM1B,IAAIW,UAAA,MAAAC,MAAA,CAAAC,kBAAA,CAAiBC,kCAAA,CAAarB,UAAA,EAAYe,CAAA,KAAIA,CAAA,EAAE;EACpD,IAAIO,UAAA,MAAAH,MAAA,CAAAC,kBAAA,CAAiBC,kCAAA,CAAarB,UAAA,EAAYgB,CAAA,KAAIA,CAAA,EAAE;EACpD,IAAIO,wBAAA,GAA2BL,UAAA,CAAWM,KAAK,CAAC,GAAGF,UAAA,CAAWG,MAAM,EAAEC,SAAS,CAAC,UAACX,CAAA,EAAGN,CAAA;IAAA,OAAMM,CAAA,KAAMO,UAAU,CAACb,CAAA,CAAE;EAAA;EAC7G,IAAIc,wBAAA,KAA6B,IAAI;IAEnCR,CAAA,GAAIG,UAAU,CAACK,wBAAA,CAAyB;IACxCP,CAAA,GAAIM,UAAU,CAACC,wBAAA,CAAyB;IACxC,OAAOR,CAAA,CAAER,KAAK,GAAGS,CAAA,CAAET,KAAK;EAC1B;EAGA,IAAIW,UAAA,CAAWQ,SAAS,CAAC,UAAA3B,IAAA;IAAA,OAAQA,IAAA,KAASiB,CAAA;EAAA,MAAM,GAC9C,OAAO,OACF,IAAIM,UAAA,CAAWI,SAAS,CAAC,UAAA3B,IAAA;IAAA,OAAQA,IAAA,KAASgB,CAAA;EAAA,MAAM,GACrD,OAAO;EAIT,OAAO;AACT;AAEA,SAASM,mCAAgBrB,UAA+B,EAAED,IAAa;EACrE,IAAI4B,OAAA,GAAqB,EAAE;EAE3B,IAAIC,QAAA,GAA2B7B,IAAA;EAC/B,OAAO,CAAA6B,QAAA,aAAAA,QAAA,uBAAAA,QAAA,CAAUX,SAAS,KAAI,MAAM;IAClCW,QAAA,GAAW5B,UAAA,CAAW6B,OAAO,CAACD,QAAA,CAASX,SAAS;IAChD,IAAIW,QAAA,EACFD,OAAA,CAAQG,OAAO,CAACF,QAAA;EAEpB;EAEA,OAAOD,OAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}