{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"labelProps\", \"inputProps\", \"descriptionProps\", \"errorMessageProps\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useTextField as $2d73ec29415bd339$export$712718f7aec83d5 } from \"./useTextField.mjs\";\nimport { useEffectEvent as $jyGKS$useEffectEvent, mergeProps as $jyGKS$mergeProps } from \"@react-aria/utils\";\nimport { useEffect as $jyGKS$useEffect, useRef as $jyGKS$useRef } from \"react\";\nfunction $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' && window.InputEvent && typeof InputEvent.prototype.getTargetRanges === 'function';\n}\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {\n  var onBeforeInputFallback = (0, $jyGKS$useEffectEvent)(function (e) {\n    var input = inputRef.current;\n    if (!input) return;\n    var nextValue = null;\n    switch (e.inputType) {\n      case 'historyUndo':\n      case 'historyRedo':\n        return;\n      case 'insertLineBreak':\n        return;\n      case 'deleteContent':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case 'deleteContentForward':\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case 'deleteContentBackward':\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        nextValue = input.value.slice(input.selectionStart);\n        break;\n      default:\n        if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n        break;\n    }\n    if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n  });\n  (0, $jyGKS$useEffect)(function () {\n    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent() || !inputRef.current) return;\n    var input = inputRef.current;\n    input.addEventListener('beforeinput', onBeforeInputFallback, false);\n    return function () {\n      input.removeEventListener('beforeinput', onBeforeInputFallback, false);\n    };\n  }, [inputRef, onBeforeInputFallback]);\n  var onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? function (e) {\n    var nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n    if (!state.validate(nextValue)) e.preventDefault();\n  } : null;\n  var _ref = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef),\n    labelProps = _ref.labelProps,\n    textFieldProps = _ref.inputProps,\n    descriptionProps = _ref.descriptionProps,\n    errorMessageProps = _ref.errorMessageProps,\n    validation = _objectWithoutProperties(_ref, _excluded);\n  var compositionStartState = (0, $jyGKS$useRef)(null);\n  return _objectSpread({\n    inputProps: (0, $jyGKS$mergeProps)(textFieldProps, {\n      onBeforeInput: onBeforeInput,\n      onCompositionStart: function onCompositionStart() {\n        var _inputRef$current = inputRef.current,\n          value = _inputRef$current.value,\n          selectionStart = _inputRef$current.selectionStart,\n          selectionEnd = _inputRef$current.selectionEnd;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n      onCompositionEnd: function onCompositionEnd() {\n        if (inputRef.current && !state.validate(inputRef.current.value)) {\n          var _compositionStartStat = compositionStartState.current,\n            value = _compositionStartStat.value,\n            selectionStart = _compositionStartStat.selectionStart,\n            selectionEnd = _compositionStartStat.selectionEnd;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state.setInputValue(value);\n        }\n      }\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  }, validation);\n}\nexport { $d841c8010a73d545$export$4f384c9210e583c3 as useFormattedTextField };","map":{"version":3,"names":["$d841c8010a73d545$var$supportsNativeBeforeInputEvent","window","InputEvent","prototype","getTargetRanges","$d841c8010a73d545$export$4f384c9210e583c3","props","state","inputRef","onBeforeInputFallback","$jyGKS$useEffectEvent","e","input","current","nextValue","inputType","value","slice","selectionStart","selectionEnd","data","validate","preventDefault","$jyGKS$useEffect","addEventListener","removeEventListener","onBeforeInput","target","_ref","$2d73ec29415bd339$export$712718f7aec83d5","labelProps","textFieldProps","inputProps","descriptionProps","errorMessageProps","validation","_objectWithoutProperties","_excluded","compositionStartState","$jyGKS$useRef","_objectSpread","$jyGKS$mergeProps","onCompositionStart","_inputRef$current","onCompositionEnd","_compositionStartStat","setSelectionRange","setInputValue"],"sources":["C:\\Users\\merve\\node_modules\\@react-aria\\textfield\\dist\\packages\\@react-aria\\textfield\\src\\useFormattedTextField.ts"],"sourcesContent":["/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTextFieldProps} from '@react-types/textfield';\nimport {mergeProps, useEffectEvent} from '@react-aria/utils';\nimport {RefObject} from '@react-types/shared';\nimport {TextFieldAria, useTextField} from './useTextField';\nimport {useEffect, useRef} from 'react';\n\ninterface FormattedTextFieldState {\n  validate: (val: string) => boolean,\n  setInputValue: (val: string) => void\n}\n\n\nfunction supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' &&\n    window.InputEvent &&\n    typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nexport function useFormattedTextField(props: AriaTextFieldProps, state: FormattedTextFieldState, inputRef: RefObject<HTMLInputElement | null>): TextFieldAria {\n  // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n  let onBeforeInputFallback = useEffectEvent((e: InputEvent) => {\n    let input = inputRef.current;\n    if (!input) {\n      return;\n    }\n\n    // Compute the next value of the input if the event is allowed to proceed.\n    // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n    let nextValue: string | null = null;\n    switch (e.inputType) {\n      case 'historyUndo':\n      case 'historyRedo':\n        // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n        // because presumably the input would have already been validated previously.\n        return;\n      case 'insertLineBreak':\n        // Explicitly allow \"insertLineBreak\" event, to allow onSubmit for \"enter\" key. e.data is null in this case.\n        return;\n      case 'deleteContent':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        nextValue = input.value.slice(0, input.selectionStart!) + input.value.slice(input.selectionEnd!);\n        break;\n      case 'deleteContentForward':\n        // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n        // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n        // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n        // If we support additional locales in the future, this may need to change.\n        nextValue = input.selectionEnd === input.selectionStart\n          ? input.value.slice(0, input.selectionStart!) + input.value.slice(input.selectionEnd! + 1)\n          : input.value.slice(0, input.selectionStart!) + input.value.slice(input.selectionEnd!);\n        break;\n      case 'deleteContentBackward':\n        nextValue = input.selectionEnd === input.selectionStart\n          ? input.value.slice(0, input.selectionStart! - 1) + input.value.slice(input.selectionStart!)\n          : input.value.slice(0, input.selectionStart!) + input.value.slice(input.selectionEnd!);\n        break;\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        nextValue = input.value.slice(input.selectionStart!);\n        break;\n      default:\n        if (e.data != null) {\n          nextValue =\n            input.value.slice(0, input.selectionStart!) +\n            e.data +\n            input.value.slice(input.selectionEnd!);\n        }\n        break;\n    }\n\n    // If we did not compute a value, or the new value is invalid, prevent the event\n    // so that the browser does not update the input text, move the selection, or add to\n    // the undo/redo stack.\n    if (nextValue == null || !state.validate(nextValue)) {\n      e.preventDefault();\n    }\n  });\n\n  useEffect(() => {\n    if (!supportsNativeBeforeInputEvent() || !inputRef.current) {\n      return;\n    }\n\n    let input = inputRef.current;\n    input.addEventListener('beforeinput', onBeforeInputFallback, false);\n    return () => {\n      input.removeEventListener('beforeinput', onBeforeInputFallback, false);\n    };\n  }, [inputRef, onBeforeInputFallback]);\n\n  let onBeforeInput = !supportsNativeBeforeInputEvent()\n    ? e => {\n      let nextValue =\n        e.target.value.slice(0, e.target.selectionStart) +\n        e.data +\n        e.target.value.slice(e.target.selectionEnd);\n\n      if (!state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    }\n    : null;\n\n  let {labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps, ...validation} = useTextField(props, inputRef);\n\n  let compositionStartState = useRef<{value: string, selectionStart: number | null, selectionEnd: number | null} | null>(null);\n  return {\n    inputProps: mergeProps(\n      textFieldProps,\n      {\n        onBeforeInput,\n        onCompositionStart() {\n          // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n          // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n          // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n          // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n          // nor would we want to cancel them because the input from the user is incomplete at that point.\n          // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n          // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n          // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n          // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n          // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n          // are implemented, there is no other way to prevent composed input.\n          // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n          let {value, selectionStart, selectionEnd} = inputRef.current!;\n          compositionStartState.current = {value, selectionStart, selectionEnd};\n        },\n        onCompositionEnd() {\n          if (inputRef.current && !state.validate(inputRef.current.value)) {\n            // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n            // But also update the value in React state as well so it is correct for future updates.\n            let {value, selectionStart, selectionEnd} = compositionStartState.current!;\n            inputRef.current.value = value;\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n            state.setInputValue(value);\n          }\n        }\n      }\n    ),\n    labelProps,\n    descriptionProps,\n    errorMessageProps,\n    ...validation\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}