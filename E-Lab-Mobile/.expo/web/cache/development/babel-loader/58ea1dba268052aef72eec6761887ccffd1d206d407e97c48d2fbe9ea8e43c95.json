{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useControlledState as $69RjW$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $69RjW$useMemo } from \"react\";\nfunction $ad999b7f496648d1$export$8deac67f4addf270(props) {\n  var _props$selectionMode = props.selectionMode,\n    selectionMode = _props$selectionMode === void 0 ? 'single' : _props$selectionMode,\n    disallowEmptySelection = props.disallowEmptySelection,\n    _props$isDisabled = props.isDisabled,\n    isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled;\n  var _ref = (0, $69RjW$useControlledState)((0, $69RjW$useMemo)(function () {\n      return props.selectedKeys ? new Set(props.selectedKeys) : undefined;\n    }, [props.selectedKeys]), (0, $69RjW$useMemo)(function () {\n      return props.defaultSelectedKeys ? new Set(props.defaultSelectedKeys) : new Set();\n    }, [props.defaultSelectedKeys]), props.onSelectionChange),\n    _ref2 = _slicedToArray(_ref, 2),\n    selectedKeys = _ref2[0],\n    setSelectedKeys = _ref2[1];\n  return {\n    selectionMode: selectionMode,\n    isDisabled: isDisabled,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    toggleKey: function toggleKey(key) {\n      var keys;\n      if (selectionMode === 'multiple') {\n        keys = new Set(selectedKeys);\n        if (keys.has(key) && (!disallowEmptySelection || keys.size > 1)) keys.delete(key);else keys.add(key);\n      } else keys = new Set(selectedKeys.has(key) && !disallowEmptySelection ? [] : [key]);\n      setSelectedKeys(keys);\n    },\n    setSelected: function setSelected(key, isSelected) {\n      if (isSelected !== selectedKeys.has(key)) this.toggleKey(key);\n    }\n  };\n}\nexport { $ad999b7f496648d1$export$8deac67f4addf270 as useToggleGroupState };","map":{"version":3,"names":["$ad999b7f496648d1$export$8deac67f4addf270","props","_props$selectionMode","selectionMode","disallowEmptySelection","_props$isDisabled","isDisabled","_ref","$69RjW$useControlledState","$69RjW$useMemo","selectedKeys","Set","undefined","defaultSelectedKeys","onSelectionChange","_ref2","_slicedToArray","setSelectedKeys","toggleKey","key","keys","has","size","delete","add","setSelected","isSelected"],"sources":["C:\\Users\\merve\\node_modules\\@react-stately\\toggle\\dist\\packages\\@react-stately\\toggle\\src\\useToggleGroupState.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo} from 'react';\n\nexport interface ToggleGroupProps {\n  /** Whether single or multiple selection is enabled. */\n  selectionMode?: 'single' | 'multiple',\n  /** Whether the collection allows empty selection. */\n  disallowEmptySelection?: boolean,\n  /** The currently selected keys in the collection (controlled). */\n  selectedKeys?: Iterable<Key>,\n  /** The initial selected keys in the collection (uncontrolled). */\n  defaultSelectedKeys?: Iterable<Key>,\n  /** Handler that is called when the selection changes. */\n  onSelectionChange?: (keys: Set<Key>) => void,\n  /** Whether all items are disabled. */\n  isDisabled?: boolean\n}\n\nexport interface ToggleGroupState {\n  /** Whether single or multiple selection is enabled. */\n  readonly selectionMode: 'single' | 'multiple',\n\n  /** Whether all items are disabled. */\n  readonly isDisabled: boolean,\n  \n  /** A set of keys for items that are selected. */\n  readonly selectedKeys: Set<Key>,\n\n  /** Toggles the selected state for an item by its key. */\n  toggleKey(key: Key): void,\n\n  /** Sets whether the given key is selected. */\n  setSelected(key: Key, isSelected: boolean): void,\n\n  /** Replaces the set of selected keys. */\n  setSelectedKeys(keys: Set<Key>): void\n}\n\n/**\n * Manages state for a group of toggles.\n * It supports both single and multiple selected items.\n */\nexport function useToggleGroupState(props: ToggleGroupProps): ToggleGroupState {\n  let {selectionMode = 'single', disallowEmptySelection, isDisabled = false} = props;\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    useMemo(() => props.selectedKeys ? new Set(props.selectedKeys) : undefined, [props.selectedKeys]),\n    useMemo(() => props.defaultSelectedKeys ? new Set(props.defaultSelectedKeys) : new Set(), [props.defaultSelectedKeys]),\n    props.onSelectionChange\n  );\n\n  return {\n    selectionMode,\n    isDisabled,\n    selectedKeys,\n    setSelectedKeys,\n    toggleKey(key) {\n      let keys: Set<Key>;\n      if (selectionMode === 'multiple') {\n        keys = new Set(selectedKeys);\n        if (keys.has(key) && (!disallowEmptySelection || keys.size > 1)) {\n          keys.delete(key);\n        } else {\n          keys.add(key);\n        }\n      } else {\n        keys = new Set(selectedKeys.has(key) && !disallowEmptySelection ? [] : [key]);\n      }\n  \n      setSelectedKeys(keys);\n    },\n    setSelected(key, isSelected) {\n      if (isSelected !== selectedKeys.has(key)) {\n        this.toggleKey(key);\n      }\n    }\n  };\n}\n"],"mappings":";;;AAuDO,SAASA,0CAAoBC,KAAuB;EACzD,IAAAC,oBAAA,GAA6ED,KAAA,CAAzEE,aAAA;IAACA,aAAA,GAAAD,oBAAA,cAAgB,WAAAA,oBAAA;IAAUE,sBAAsB,GAAwBH,KAAA,CAAxDG,sBAAA;IAAAC,iBAAA,GAAwDJ,KAAA,CAAxBK,UAAA;IAAEA,UAAA,GAAAD,iBAAA,cAAa,QAAAA,iBAAA;EACpE,IAAAE,IAAA,GAAsC,IAAAC,yBAAiB,EACrD,IAAAC,cAAM,EAAE;MAAA,OAAMR,KAAA,CAAMS,YAAY,GAAG,IAAIC,GAAA,CAAIV,KAAA,CAAMS,YAAY,IAAIE,SAAA;IAAA,GAAW,CAACX,KAAA,CAAMS,YAAY,CAAC,GAChG,IAAAD,cAAM,EAAE;MAAA,OAAMR,KAAA,CAAMY,mBAAmB,GAAG,IAAIF,GAAA,CAAIV,KAAA,CAAMY,mBAAmB,IAAI,IAAIF,GAAA;IAAA,GAAO,CAACV,KAAA,CAAMY,mBAAmB,CAAC,GACrHZ,KAAA,CAAMa,iBAAiB;IAAAC,KAAA,GAAAC,cAAA,CAAAT,IAAA;IAHpBG,YAAA,GAAAK,KAAA;IAAcE,eAAA,GAAAF,KAAA;EAMnB,OAAO;mBACLZ,aAAA;gBACAG,UAAA;kBACAI,YAAA;qBACAO,eAAA;IACAC,SAAA,WAAAA,UAAUC,GAAG;MACX,IAAIC,IAAA;MACJ,IAAIjB,aAAA,KAAkB,YAAY;QAChCiB,IAAA,GAAO,IAAIT,GAAA,CAAID,YAAA;QACf,IAAIU,IAAA,CAAKC,GAAG,CAACF,GAAA,MAAS,CAACf,sBAAA,IAA0BgB,IAAA,CAAKE,IAAI,GAAG,IAC3DF,IAAA,CAAKG,MAAM,CAACJ,GAAA,OAEZC,IAAA,CAAKI,GAAG,CAACL,GAAA;MAEb,OACEC,IAAA,GAAO,IAAIT,GAAA,CAAID,YAAA,CAAaW,GAAG,CAACF,GAAA,KAAQ,CAACf,sBAAA,GAAyB,EAAE,GAAG,CAACe,GAAA,CAAI;MAG9EF,eAAA,CAAgBG,IAAA;IAClB;IACAK,WAAA,WAAAA,YAAYN,GAAG,EAAEO,UAAU;MACzB,IAAIA,UAAA,KAAehB,YAAA,CAAaW,GAAG,CAACF,GAAA,GAClC,IAAI,CAACD,SAAS,CAACC,GAAA;IAEnB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}